<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

<h1 align="center">@nahnah/nestjs-auth-module</h1>
<p align="center">A production-ready authentication module for NestJS featuring JWT, Passport strategies, and seamless integration.</p>

<p align="center">                                                                                     <a href="https://www.npmjs.com/package/@nahnah/nestjs-auth-module" target="_blank"><img src="https://img.shields.io/npm/v/@nahnah/nestjs-auth-module.svg" alt="NPM Version" /></a>
  <a href="LICENSE" target="_blank"><img src="https://img.shields.io/npm/l/@nahnah/nestjs-auth-module.svg" alt="Package License" /></a>
  <a href="https://www.npmjs.com/package/@nahnah/nestjs-auth-module" target="_blank"><img src="https://img.shields.io/npm/dt/@nahnah/nestjs-auth-module.svg" alt="NPM Downloads" /></a>
  <a href="https://github.com/tgenericx/nestjs-auth-module/stargazers" target="_blank"><img src="https://img.shields.io/github/stars/tgenericx/nestjs-auth-module.svg" alt="GitHub Stars" /></a>
  <a href="https://github.com/tgenericx/nestjs-auth-module/network/members" target="_blank"><img src="https://img.shields.io/github/forks/tgenericx/nestjs-auth-module.svg" alt="GitHub Forks" /></a>
</p>

<p align="center">
  <a href="https://github.com/tgenericx/nestjs-auth-module/issues" target="_blank"><img src="https://img.shields.io/github/issues/tgenericx/nestjs-auth-module.svg" alt="GitHub Issues" /></a>
  <a href="https://github.com/tgenericx/nestjs-auth-module/pulls" target="_blank"><img src="https://img.shields.io/github/issues-pr/tgenericx/nestjs-auth-module.svg" alt="GitHub Pull Requests" /></a>
</p>

<p align="center">
  <img src="https://img.shields.io/badge/TypeScript-‚≠ê-blue.svg" alt="TypeScript" />
  <img src="https://img.shields.io/badge/NestJS-‚≠ê-red.svg" alt="NestJS" />
  <img src="https://img.shields.io/badge/JWT-‚≠ê-yellowgreen.svg" alt="JWT" />
  <img src="https://img.shields.io/badge/Passport-‚≠ê-blueviolet.svg" alt="Passport" />
  <img src="https://img.shields.io/badge/Node.js-‚≠ê-green.svg" alt="Node.js" />
</p>

---

## üìñ Overview

`@nahnah/nestjs-auth-module` is a plug-and-play authentication module for NestJS that supports JWT-based access and refresh tokens, secure password hashing with Argon2, optional Google OAuth flow, role-based authorization, and a clean interface-based design so you can plug in your own user repo and email service. Ideal for rapid setup of authentication in production-grade applications.

---

## ‚ú® Features

- üîê **JWT Authentication** - Access & refresh tokens with configurable expiration
- üîë **Password Management** - Secure Argon2 hashing for credentials
- üåê **Google OAuth** - Optional OAuth 2.0 integration
- üë• **Role-Based Access Control** - Decorator-based authorization (`@Roles()`)
- üéØ **Simple API** - Clean decorators (`@CurrentUser`, `@Public`)
- üîå **Database Agnostic** - Bring your own repository implementation
- üì¶ **Modular Design** - Enable only the features you need
- üõ°Ô∏è **Type-Safe** - Full TypeScript support with strict types
- ‚ö° **Zero Configuration** - Sensible defaults with optional customization

---

## üì¶ Installation

```bash
npm install @nahnah/nestjs-auth-module
# or
yarn add @nahnah/nestjs-auth-module
# or
pnpm add @nahnah/nestjs-auth-module
```

Required Peer Dependencies

```bash
npm install @nestjs/common @nestjs/core @nestjs/jwt @nestjs/passport \
  passport passport-jwt argon2 class-validator class-transformer
```

Optional Dependencies (for Google OAuth)

```bash
npm install passport-google-oauth20 @types/passport-google-oauth20
```

---

üöÄ Quick Start

1. Implement User Repository

The module requires you to provide a repository that implements the UserRepository interface:

```typescript
// users/user-repository.service.ts
import { Injectable } from '@nestjs/common';
import { UserRepository, AuthUser } from '@nahnah/nestjs-auth-module';

// Your user entity (can have additional fields)
export interface User extends AuthUser {
  // AuthUser provides: id, email, password, googleId, isEmailVerified, roles
  firstName?: string;
  lastName?: string;
  createdAt?: Date;
}

@Injectable()
export class UserRepositoryService implements UserRepository<User> {
  // In-memory storage for demo (use a real database in production)
  private users = new Map<string, User>();

  async findById(id: string): Promise<User | null> {
    return this.users.get(id) || null;
  }

  async findByEmail(email: string): Promise<User | null> {
    return (
      Array.from(this.users.values()).find((u) => u.email === email) || null
    );
  }

  async findByGoogleId(googleId: string): Promise<User | null> {
    return (
      Array.from(this.users.values()).find((u) => u.googleId === googleId) ||
      null
    );
  }

  async create(data: Partial<User>): Promise<User> {
    const user: User = {
      id: Math.random().toString(36),
      email: data.email!,
      password: data.password || null,
      googleId: data.googleId || null,
      isEmailVerified: data.isEmailVerified ?? false,
      roles: data.roles || ['user'],
      firstName: data.firstName,
      lastName: data.lastName,
      createdAt: new Date(),
    };
    this.users.set(user.id, user);
    return user;
  }

  async update(id: string, data: Partial<User>): Promise<User> {
    const user = await this.findById(id);
    if (!user) throw new Error('User not found');

    Object.assign(user, data);
    this.users.set(id, user);
    return user;
  }
}
```

2. Configure Auth Module

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthModule } from '@nahnah/nestjs-auth-module';
import { UserRepositoryService } from './users/user-repository.service';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),

    // Configure authentication
    AuthModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (config: ConfigService) => ({
        jwt: {
          accessTokenSignOptions: {
            secret: config.get('JWT_SECRET')!,
            expiresIn: '15m',
          },
          refreshTokenSignOptions: {
            secret: config.get('JWT_REFRESH_SECRET')!,
            expiresIn: '7d',
          },
        },
        // Optional: Enable password-based auth
        credentials: {},

        // Optional: Enable Google OAuth
        google: {
          clientID: config.get('GOOGLE_CLIENT_ID')!,
          clientSecret: config.get('GOOGLE_CLIENT_SECRET')!,
          callbackURL: config.get('GOOGLE_CALLBACK_URL')!,
        },
      }),
      userRepository: UserRepositoryService,
      enabledCapabilities: ['credentials', 'google'], // Enable features
    }),
  ],
  providers: [UserRepositoryService],
})
export class AppModule {}
```

3. Create Auth Controller

```typescript
// auth/auth.controller.ts
import {
  Controller,
  Post,
  Get,
  Body,
  UseGuards,
  Req,
  Res,
} from '@nestjs/common';
import { Response } from 'express';
import {
  CredentialsAuthService,
  GoogleAuthService,
  TokenService,
  Public,
  JwtAuthGuard,
  GoogleAuthGuard,
  CurrentUser,
  Roles,
  RolesGuard,
  RegistrationInput,
  LoginInput,
  PasswordChangeInput,
  RequestUser,
} from '@nahnah/nestjs-auth-module';

@Controller('auth')
export class AuthController {
  constructor(
    private readonly credentialsAuth: CredentialsAuthService,
    private readonly googleAuth: GoogleAuthService,
    private readonly tokenService: TokenService,
  ) {}

  // ========================================
  // Password-based Authentication
  // ========================================

  @Public()
  @Post('register')
  async register(@Body() dto: RegistrationInput) {
    return this.credentialsAuth.register(dto);
  }

  @Public()
  @Post('login')
  async login(@Body() dto: LoginInput) {
    return this.credentialsAuth.login(dto);
  }

  @Public()
  @Post('refresh')
  async refresh(@Body('refreshToken') refreshToken: string) {
    const payload = await this.tokenService.verifyRefreshToken(refreshToken);
    const user = await this.credentialsAuth.validateUser(payload.sub);
    const accessToken = this.tokenService.generateAccessToken(user);
    return { accessToken };
  }

  @UseGuards(JwtAuthGuard)
  @Post('logout')
  async logout() {
    return { message: 'Logged out successfully' };
  }

  @UseGuards(JwtAuthGuard)
  @Post('change-password')
  async changePassword(
    @CurrentUser('userId') userId: string,
    @Body() dto: Omit<PasswordChangeInput, 'userId'>,
  ) {
    return this.credentialsAuth.changePassword({ userId, ...dto });
  }

  // ========================================
  // Google OAuth
  // ========================================

  @Public()
  @Get('google')
  @UseGuards(GoogleAuthGuard)
  async googleLogin() {
    // Initiates OAuth flow
  }

  @Public()
  @Get('google/callback')
  @UseGuards(GoogleAuthGuard)
  async googleCallback(@Req() req: any, @Res() res: Response) {
    const result = await this.googleAuth.handleOAuthCallback(req.user);

    // Redirect to frontend with tokens
    return res.redirect(
      `${process.env.FRONTEND_URL}/auth/callback?` +
        `accessToken=${result.tokens.accessToken}&` +
        `refreshToken=${result.tokens.refreshToken}`,
    );
  }

  // ========================================
  // Protected Routes
  // ========================================

  @UseGuards(JwtAuthGuard)
  @Get('me')
  async getMe(@CurrentUser() user: RequestUser) {
    return { user };
  }

  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin')
  @Get('admin-only')
  async adminOnly() {
    return { message: 'Admin access granted' };
  }
}
```

4. Environment Variables

```env
# .env
JWT_SECRET=your-secret-key-change-in-production
JWT_REFRESH_SECRET=your-refresh-secret-key-change-in-production

# Google OAuth (optional)
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GOOGLE_CALLBACK_URL=http://localhost:3000/auth/google/callback

# Frontend URL (for OAuth redirects)
FRONTEND_URL=http://localhost:4200
```

---

üéØ Core Concepts

Capabilities

Enable only the authentication methods you need:

```typescript
AuthModule.forRootAsync({
  // ...
  enabledCapabilities: ['credentials'], // Only password auth
  // enabledCapabilities: ['google'], // Only Google OAuth
  // enabledCapabilities: ['credentials', 'google'], // Both
});
```

User Repository Pattern

The module is database-agnostic. You provide a repository that implements the UserRepository<T> interface:

```typescript
interface UserRepository<User extends Partial<AuthUser>> {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  create(data: Partial<User>): Promise<User>;
  update(id: string, data: Partial<User>): Promise<User>;
}
```

Your User type must extend Partial<AuthUser>:

```typescript
interface AuthUser {
  id: string;
  email: string;
  password?: string | null;
  googleId?: string | null;
  isEmailVerified: boolean;
  roles: string[];
}
```

---

üé® Decorators

@Public()

Mark routes as publicly accessible (skip authentication):

```typescript
@Public()
@Get('health')
async health() {
  return { status: 'ok' };
}
```

@CurrentUser()

Extract authenticated user from request:

```typescript
// Get full user object
@Get('profile')
async getProfile(@CurrentUser() user: RequestUser) {
  return { user };
}

// Get specific property
@Get('user-id')
async getUserId(@CurrentUser('userId') userId: string) {
  return { userId };
}
```

@Roles()

Require specific roles (use with RolesGuard):

```typescript
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('admin', 'moderator')
@Delete('users/:id')
async deleteUser(@Param('id') id: string) {
  // Only admin or moderator can access
}
```

---

üîß Services

CredentialsAuthService

Handles password-based authentication:

```typescript
class CredentialsAuthService {
  register(dto: RegistrationInput): Promise<AuthResponse>;
  login(dto: LoginInput): Promise<LoginResponse>;
  changePassword(dto: PasswordChangeInput): Promise<{ message: string }>;
  setPassword(dto: PasswordSetInput): Promise<{ message: string }>;
  verifyEmail(userId: string): Promise<{ message: string }>;
  validateUser(userId: string): Promise<User>;
}
```

GoogleAuthService

Handles Google OAuth flow:

```typescript
class GoogleAuthService {
  handleOAuthCallback(requestUser: RequestUser): Promise<GoogleAuthResponse>;
  unlinkGoogleAccount(userId: string): Promise<{ message: string }>;
  isGoogleLinked(userId: string): Promise<boolean>;
}
```

TokenService

Manages JWT tokens:

```typescript
class TokenService {
  generateAccessToken(user: BaseUser): string;
  generateRefreshToken(user: { id: string }): string;
  generateTokens(user: AuthUser): TokenPair;
  verifyAccessToken(token: string): Promise<JwtPayload>;
  verifyRefreshToken(token: string): Promise<{ sub: string }>;
  decodeToken(token: string): JwtPayload | null;
}
```

PasswordService

Secure password operations:

```typescript
class PasswordService {
  hash(password: string): Promise<string>;
  verify(password: string, hash: string): Promise<boolean>;
  generateResetToken(): string;
}
```

---

üîê Security Best Practices

1. Use Environment Variables for secrets
2. HTTPS in Production - Always use HTTPS for OAuth callbacks
3. Refresh Token Rotation - Implement token rotation (TODO)
4. Rate Limiting - Add rate limiting to auth endpoints
5. Password Policies - Enforce strong passwords using validation

```typescript
// Example: Add validation to your DTOs
import { IsEmail, IsStrongPassword, MinLength } from 'class-validator';

export class RegisterDto implements RegistrationInput {
  @IsEmail()
  email: string;

  @IsStrongPassword({
    minLength: 8,
    minLowercase: 1,
    minUppercase: 1,
    minNumbers: 1,
    minSymbols: 1,
  })
  password: string;
}
```

---

üìö Advanced Usage

Custom User Type with Additional Fields

```typescript
// Define your extended user type
export interface AppUser extends AuthUser {
  firstName: string;
  lastName: string;
  phoneNumber?: string;
  avatar?: string;
  createdAt: Date;
  updatedAt: Date;
}

// Use in repository
@Injectable()
export class UserRepositoryService implements UserRepository<AppUser> {
  // All methods now work with AppUser
}

// Use in auth service
@Injectable()
export class MyAuthService {
  constructor(
    private readonly credentialsAuth: CredentialsAuthService<AppUser>,
  ) {}

  async registerWithProfile(dto: RegisterDto & { firstName: string }) {
    return this.credentialsAuth.register({
      email: dto.email,
      password: dto.password,
      firstName: dto.firstName,
      // Additional fields are passed through
    });
  }
}
```

Global Authentication Guard

```typescript
// main.ts
import { NestFactory, Reflector } from '@nestjs/core';
import { JwtAuthGuard } from '@nahnah/nestjs-auth-module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Apply JWT guard globally
  const reflector = app.get(Reflector);
  app.useGlobalGuards(new JwtAuthGuard(reflector));

  await app.listen(3000);
}
```

Custom Registration with Email Verification

```typescript
@Injectable()
export class CustomAuthService {
  constructor(
    private readonly credentialsAuth: CredentialsAuthService,
    private readonly emailService: EmailService,
  ) {}

  async registerWithVerification(dto: RegistrationInput) {
    // Register user
    const result = await this.credentialsAuth.register(dto);

    // Send verification email
    const verificationToken = this.generateVerificationToken(result.user.id);
    await this.emailService.sendVerificationEmail(
      result.user.email,
      verificationToken,
    );

    return {
      ...result,
      message: 'Registration successful. Please verify your email.',
    };
  }

  async verifyEmail(token: string) {
    const userId = this.decodeVerificationToken(token);
    return this.credentialsAuth.verifyEmail(userId);
  }
}
```

---

üìñ API Reference

Configuration Interface

```typescript
interface AuthModuleAsyncOptions<User extends Partial<AuthUser>> {
  imports?: ModuleMetadata['imports'];
  inject?: FactoryProvider['inject'];
  useFactory: (...args: any[]) => Promise<AuthModuleConfig> | AuthModuleConfig;
  userRepository: Type<UserRepository<User>>;
  enabledCapabilities: ('credentials' | 'google')[];
}

interface AuthModuleConfig {
  jwt: JwtConfig;
  credentials?: CredentialsAuthConfig;
  google?: GoogleOAuthConfig;
}

interface JwtConfig {
  accessTokenSignOptions: JwtSignOptions;
  refreshTokenSignOptions: JwtSignOptions;
}
```

---

üó∫Ô∏è Roadmap

¬∑ Refresh token rotation & blacklisting
¬∑ Magic link authentication
¬∑ Account lockout after failed attempts
¬∑ Password reset flow helpers
¬∑ Email verification flow helpers
¬∑ More OAuth providers (GitHub, Microsoft, etc.)

---

ü§ù Contributing

Contributions are welcome! Please:

1. Fork the repository
2. Create a feature branch (git checkout -b feature/amazing-feature)
3. Commit your changes (git commit -m 'Add amazing feature')
4. Push to the branch (git push origin feature/amazing-feature)
5. Open a Pull Request

---

ü™™ License

MIT ‚Äî see LICENSE for details.

---

üôè Acknowledgments

¬∑ Built with NestJS
¬∑ Uses Passport for authentication strategies
¬∑ Password hashing with Argon2

---

üí¨ Support

¬∑ üêõ Report Issues
¬∑ üí° Request Features
¬∑ ‚≠ê Star the repo if it helped you!